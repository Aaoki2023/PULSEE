import math
from cmath import exp
import numpy as np
import pandas as pd

from Operators import *

from Nuclear_Spin import *

def h_zeeman(spin, theta_z, phi_z, H_0):
    if H_0<0: raise ValueError("The modulus of the magnetic field must be a non-negative quantity")
    h_z = -spin.gyro_ratio_over_2pi*H_0* \
          (math.sin(theta_z)*math.cos(phi_z)*spin.I['x'] + \
           math.sin(theta_z)*math.sin(phi_z)*spin.I['y'] + \
           math.cos(theta_z)*spin.I['z'])
    return Observable(h_z.matrix)

def h_quadrupole(spin, e2qQ, eta, alpha_q, beta_q, gamma_q):
    if math.isclose(spin.quantum_number, 1/2, rel_tol=1e-10):
        return Observable(spin.d)*0
    I = spin.quantum_number
    h_q = (e2qQ/(I*(2*I-1)))* \
          ((1/2)*(3*(spin.I['z']**2) - Operator(spin.d)*I*(I+1))*v0_EFG(eta, alpha_q, beta_q, gamma_q)+\
           (math.sqrt(6)/4)*
           ((spin.I['z']*spin.I['+'] + spin.I['+']*spin.I['z'])*\
                             v1_EFG(-1, eta, alpha_q, beta_q, gamma_q) + \
            (spin.I['z']*spin.I['-'] + spin.I['-']*spin.I['z'])*\
                             v1_EFG(+1, eta, alpha_q, beta_q, gamma_q) + \
            (spin.I['+']**2)*\
            v2_EFG(-2, eta, alpha_q, beta_q, gamma_q) + \
            (spin.I['-']**2)*\
            v2_EFG(2, eta, alpha_q, beta_q, gamma_q)))
    return Observable(h_q.matrix)

def v0_EFG(eta, alpha_q, beta_q, gamma_q):
    if eta<0 or eta>1: raise ValueError("The asymmetry parameter must fall in the interval [0, 1]")
    v0 = (1/2)*(((3*(math.cos(beta_q))**2-1)/2) - (eta*(math.sin(beta_q))**2)*(math.cos(2*gamma_q))/2)
    return v0

def v1_EFG(sign, eta, alpha_q, beta_q, gamma_q):
    if eta<0 or eta>1: raise ValueError("The asymmetry parameter must fall in the interval [0, 1]")
    sign = np.sign(sign)
    v1 = (1/2)*\
         (
          -1j*sign*math.sqrt(3/8)*math.sin(2*beta_q)*exp(sign*1j*alpha_q)+\
          1j*(eta/(math.sqrt(6)))*math.sin(beta_q)*\
          (
           ((1+sign*math.cos(beta_q))/2)*exp(1j*(sign*alpha_q+2*gamma_q))-\
            ((1-sign*math.cos(beta_q))/2)*exp(1j*(sign*alpha_q-2*gamma_q))
          )
         )
    return v1

def v2_EFG(sign, eta, alpha_q, beta_q, gamma_q):
    if eta<0 or eta>1: raise ValueError("The asymmetry parameter must fall in the interval [0, 1]")
    sign = np.sign(sign)
    v2 = (1/2)*\
         (math.sqrt(3/8)*((math.sin(beta_q))**2)*exp(sign*2j*alpha_q)+\
          (eta/math.sqrt(6))*exp(sign*2j*alpha_q)*\
           (
            exp(2j*gamma_q)*((1+sign*math.cos(beta_q))**2)/4 +\
            exp(-2j*gamma_q)*((1-sign*math.cos(beta_q))**2)/4
           )
         )
    return v2

def h_single_mode_pulse(spin, frequency, H_1, phase, theta, phi, t):
    if frequency < 0: raise ValueError("The modulus of the angular frequency of the electromagnetic wave must be a positive quantity")
    if H_1 < 0: raise ValueError("The amplitude of the electromagnetic wave must be a positive quantity")
    h_pulse = -spin.gyro_ratio_over_2pi*H_1*\
              (math.sin(theta)*math.cos(phi)*spin.I['x'] +\
               math.sin(theta)*math.sin(phi)*spin.I['y'] +\
               math.cos(theta)*spin.I['z']
               )*\
               math.cos(2*math.pi*frequency*t-phase)
    return Observable(h_pulse.matrix)

# Returns the Hamiltonian of interaction between the nucleus and multiple single-mode electromagnetic
# pulses
def H_Multiple_Mode_Pulse(spin, mode, t):
    h_pulse = Operator(spin.d)*0
    omega = mode['frequency']
    H = mode['amplitude']
    phase = mode['phase']
    theta = mode['theta_p']
    phi = mode['phi_p']
    for i in mode.index:
        h_pulse = h_pulse + h_single_mode_pulse(spin, omega[i], H[i], phase[i], theta[i], phi[i], t)
    return Observable(h_pulse.matrix)


# Global Hamiltonian of the system (stationary term + pulse term) cast in the picture generated by
# the Operator o_change_of_picture
def H_Changed_Picture(spin, mode, h_unperturbed, o_change_of_picture, t):
    h_cp = (h_unperturbed + H_Multiple_Mode_Pulse(spin, mode, t) - \
            o_change_of_picture).changed_picture(o_change_of_picture, t)
    return Observable(h_cp.matrix)







